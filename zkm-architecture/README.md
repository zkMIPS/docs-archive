---
icon: bolt-lightning
---

# ZKM Architecture

ZKM is actively developing a zkVM solution to facilitate verifiable computation for interoperability between blockchains, IoT devices, and other web2 solutions. This involves incorporating Zero-Knowledge technology with Microprocessors without Interlocked Pipeline Stages (MIPS) architecture. The aim is to provide a verifiable computing solution to trust the computation results generated by untrusted computers and potentially store the generated ZKPs on Ethereum. Hence, ZKM envisions Ethereum as a foundational settlement layer for both blockchains and non-blockchain technologies that apply the developed zkVM.\
\
The zkVM process consists of the following steps:&#x20;

<figure><img src="https://lh7-us.googleusercontent.com/N78wJcHcsM26I--8A1uk8e64wOEv_ShGoLAEgV7ZhLG3X75D9xDo9TKf_0IrS5FLQ6-4ADXDbQ2GU6B2t9xAwkGLsrVFg2fbrzwRkrjTvxU_SH6cPShXSv5US6rojzjGECcsZXNGngraZTqhI8mNaPo" alt=""><figcaption><p>zkVM Steps</p></figcaption></figure>

1. First, we run our target program with the given input and collect every intermediary state of its execution. We call the set of all internal states the Execution Trace.
2. Then, we encode the program, its inputs, and their execution trace into sets of polynomials that represent the correct execution of that instance. This step is called arithmetization.
3. Finally, we commit to these sets of polynomials using advanced techniques that compress them into small and sophisticated cryptographic objects.
4. These cryptographic objects allow us to easily test properties of their respective polynomials, which is what our zkVM does in the final step. Specifically, we can check if the program, input, and trace polynomials are compatible and if their properties hold as they should.

The result of this process is a Zero-Knowledge Proof for the correct execution of a program. The input may or may not be public, depending on the use case.

Any program written in C, Go, Rust, etc., can be compiled using a generally available MIPS compiler into MIPS R3000 BE ELF executable. The resulting ELF file is loaded into the MIPS VM with the ELF loader. The VM executes the input executable, and the Communication Manager implements syscall handlers, which can be used by the MIPS program during execution. Finally, the zkVM generates an execution trace for the Prover, who then creates a ZK Proof.

The zkVM considers different blockchain nodes as its computations and enables them to process their private transactions and provide a ZKP to prove the validity of their results.

During the execution of the MIPS program, the zkVM meticulously verifies the input batch. As a result of this execution, an execution trace is generated, which captures the detailed sequence of operations and serves as input for the subsequent step in the process. This trace is handed over to the ZK Prover for further processing and generation of a ZK proof.
