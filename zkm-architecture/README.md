# ⚡ ZKM Architecture

ZKM is actively developing a zkVM solution to facilitate verifiable computation for interoperability between blockchains, IoT devices and other web2 solutions. This is done by incorporating Zero-Knowledge technology with MIPS with Interlocked Pipeline Stages (MIPS) architecture to provide a verifiable computing solution to trust the computation results generated by untrusted computers and potentially storing the generated ZKPs on Ethereum. Hence, ZKM’s initiative and vision for Ethereum as a foundational settlement layer for blockchains and non-blockchain technologies that apply the developed zkVM.\
\
The process of ZKM’s zkVM looks like this:&#x20;

<figure><img src="https://lh7-us.googleusercontent.com/N78wJcHcsM26I--8A1uk8e64wOEv_ShGoLAEgV7ZhLG3X75D9xDo9TKf_0IrS5FLQ6-4ADXDbQ2GU6B2t9xAwkGLsrVFg2fbrzwRkrjTvxU_SH6cPShXSv5US6rojzjGECcsZXNGngraZTqhI8mNaPo" alt=""><figcaption><p>zkVM Steps</p></figcaption></figure>

1. First we run our target program with the given input and collect every intermediary state of its execution. We call the set of all internal states the Execution Trace. ,&#x20;
2. Then, we encode the program, its inputs and their execution trace into sets of polynomials that represent the correct execution of that instance. We call this step arithmetization.&#x20;
3. Finally, we commit to these sets of polynomials using advanced techniques that compress them into small and sophisticated cryptographic objects.&#x20;
4. These cryptographic objects allow us to easily test properties of their respective polynomials, which is what our zkVM does in the final step. More specifically, we can check if the program, input and trace polynomials are compatible and if their properties hold as they should.

The result of this process is a Zero-Knowledge Proof for the correct execution of a program that is public with an input that might  or might not be public, depending on the use case.

Any program written in C, Go, Rust, etc., can be compiled using a generally available MIPS compiler into MIPS R3000 BE ELF executable. The resulting ELF file is loaded into MIPS VM with the ELF loader. The VM executes the input executable. Communication Manager implements syscalls handlers, which can be used by the MIPS program during execution. Finally, the zkVM generates an be execution trace for the verifier. The Prover then creates a ZK Proof.

The zkVM will consider different blockchain nodes as its computations and enable them to process their private transactions and provide a ZKP to prove the validity of their results.

It carries out the execution of the MIPS program and meticulously verifies the input batch. As a result of this execution, an execution trace is generated, capturing the detailed sequence of operations. This execution trace serves as input for the subsequent step in the process, as it is handed over to the ZK Prover for further processing and generation of a ZK proof. Then the prover generates a ZKP proof based on the program’s execution trace.
